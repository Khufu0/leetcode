#!/usr/bin/python3

from enum import Enum
from subprocess import run, CalledProcessError
from argparse import ArgumentParser
from os import abort, path

parser = ArgumentParser(prog="run")
parser.add_argument(
    "target",
)
# general args
parser.add_argument(
    "-b",
    "--benchmark",
    action="store_true",
    default=False,
    help="time execution",
)
# cmake specific args
parser.add_argument(
    "--release",
    action="store_true",
    default=False,
    help="cmake release build",
)
parser.add_argument(
    "-r",
    "--reconfigure",
    action="store_true",
    default=False,
    help="reconfigure cmake",
)
parser.add_argument(
    "-c",
    "--clean",
    action="store_true",
    default=False,
    help="clean cmake build",
)
args = parser.parse_args()


class Lang(Enum):
    CXX = 0
    JS = 1
    PY = 2


def run(cmd: str) -> None:
    try:
        run(cmd, shell=True, check=True)
    except CalledProcessError as e:
        print(f"{str(e)}")
        abort()


def get_lang(file: str) -> Lang:
    ext = path.splitext(file)[1]
    if ext == ".py":
        return Lang.PY
    elif ext == ".js":
        return Lang.JS
    return Lang.CXX


def rm_extension(file: str) -> str:
    if file.find(".") != -1:
        return path.splitext(file)[0]
    else:
        return file


def build_cpp(cmake_target: str) -> None:
    if args.clean is True:
        run("rm build -rf")
    if path.isdir("build/") is False or args.reconfigure is True:
        build_type = "Release" if args.release else "Debug"
        run(f"cmake -B build/ -DCMAKE_BUILD_TYPE={build_type}")
    run(f"cmake --build build --parallel -t {cmake_target}")


time = f"{"time " if args.benchmark else ""}"
match get_lang(args.target):
    case Lang.CXX:
        cmake_target = rm_extension(args.target)
        build_cpp(cmake_target)
        run(f"{time}build/{cmake_target}")
    case Lang.JS:
        run(f"{time}node {args.target}")
    case Lang.PY:
        run(f"{time}python3 {args.target}")
